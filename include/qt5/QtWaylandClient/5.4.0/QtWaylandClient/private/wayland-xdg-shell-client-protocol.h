/* Generated by wayland-scanner 1.17.0 */

#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
#define XDG_SHELL_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_shell - create desktop-style surfaces
 * - @subpage page_iface_xdg_surface - desktop-style metadata interface
 * - @subpage page_iface_xdg_popup - desktop-style metadata interface
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this
 * software and its documentation for any purpose is hereby granted
 * without fee, provided that the above copyright notice appear in
 * all copies and that both that copyright notice and this permission
 * notice appear in supporting documentation, and that the name of
 * the copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 * </pre>
 */
struct wl_output;
struct wl_seat;
struct wl_surface;
struct xdg_popup;
struct xdg_shell;
struct xdg_surface;

/**
 * @page page_iface_xdg_shell xdg_shell
 * @section page_iface_xdg_shell_desc Description
 *
 * This interface is implemented by servers that provide
 * desktop-style user interfaces.
 *
 * It allows clients to associate a xdg_surface with
 * a basic surface.
 * @section page_iface_xdg_shell_api API
 * See @ref iface_xdg_shell.
 */
/**
 * @defgroup iface_xdg_shell The xdg_shell interface
 *
 * This interface is implemented by servers that provide
 * desktop-style user interfaces.
 *
 * It allows clients to associate a xdg_surface with
 * a basic surface.
 */
extern const struct wl_interface xdg_shell_interface;
/**
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides requests to treat surfaces like windows, allowing to set
 * properties like maximized, fullscreen, minimized, and to move and resize
 * them, and associate metadata like title and app id.
 *
 * On the server side the object is automatically destroyed when
 * the related wl_surface is destroyed.  On client side,
 * xdg_surface.destroy() must be called before destroying
 * the wl_surface object.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/**
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 *
 * It provides requests to treat surfaces like windows, allowing to set
 * properties like maximized, fullscreen, minimized, and to move and resize
 * them, and associate metadata like title and app id.
 *
 * On the server side the object is automatically destroyed when
 * the related wl_surface is destroyed.  On client side,
 * xdg_surface.destroy() must be called before destroying
 * the wl_surface object.
 */
extern const struct wl_interface xdg_surface_interface;
/**
 * @page page_iface_xdg_popup xdg_popup
 * @section page_iface_xdg_popup_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style popups/menus. A popup
 * surface is a transient surface with an added pointer grab.
 *
 * An existing implicit grab will be changed to owner-events mode,
 * and the popup grab will continue after the implicit grab ends
 * (i.e. releasing the mouse button does not cause the popup to be
 * unmapped).
 *
 * The popup grab continues until the window is destroyed or a mouse
 * button is pressed in any other clients window. A click in any of
 * the clients surfaces is reported as normal, however, clicks in
 * other clients surfaces will be discarded and trigger the callback.
 *
 * The x and y arguments specify the locations of the upper left
 * corner of the surface relative to the upper left corner of the
 * parent surface, in surface local coordinates.
 *
 * xdg_popup surfaces are always transient for another surface.
 * @section page_iface_xdg_popup_api API
 * See @ref iface_xdg_popup.
 */
/**
 * @defgroup iface_xdg_popup The xdg_popup interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style popups/menus. A popup
 * surface is a transient surface with an added pointer grab.
 *
 * An existing implicit grab will be changed to owner-events mode,
 * and the popup grab will continue after the implicit grab ends
 * (i.e. releasing the mouse button does not cause the popup to be
 * unmapped).
 *
 * The popup grab continues until the window is destroyed or a mouse
 * button is pressed in any other clients window. A click in any of
 * the clients surfaces is reported as normal, however, clicks in
 * other clients surfaces will be discarded and trigger the callback.
 *
 * The x and y arguments specify the locations of the upper left
 * corner of the surface relative to the upper left corner of the
 * parent surface, in surface local coordinates.
 *
 * xdg_popup surfaces are always transient for another surface.
 */
extern const struct wl_interface xdg_popup_interface;

#ifndef XDG_SHELL_VERSION_ENUM
#define XDG_SHELL_VERSION_ENUM
/**
 * @ingroup iface_xdg_shell
 * latest protocol version
 *
 * The 'current' member of this enum gives the version of the
 * protocol.  Implementations can compare this to the version
 * they implement using static_assert to ensure the protocol and
 * implementation versions match.
 */
enum xdg_shell_version {
	/**
	 * Always the latest version
	 */
	XDG_SHELL_VERSION_CURRENT = 3,
};
#endif /* XDG_SHELL_VERSION_ENUM */

/**
 * @ingroup iface_xdg_shell
 * @struct xdg_shell_listener
 */
struct xdg_shell_listener {
	/**
	 * check if the client is alive
	 *
	 * The ping event asks the client if it's still alive. Pass the
	 * serial specified in the event back to the compositor by sending
	 * a "pong" request back with the specified serial.
	 *
	 * Compositors can use this to determine if the client is still
	 * alive. It's unspecified what will happen if the client doesn't
	 * respond to the ping request, or in what timeframe. Clients
	 * should try to respond in a reasonable amount of time.
	 * @param serial pass this to the callback
	 */
	void (*ping)(void *data,
		     struct xdg_shell *xdg_shell,
		     uint32_t serial);
};

/**
 * @ingroup iface_xdg_shell
 */
static inline int
xdg_shell_add_listener(struct xdg_shell *xdg_shell,
		       const struct xdg_shell_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_shell,
				     (void (**)(void)) listener, data);
}

#define XDG_SHELL_USE_UNSTABLE_VERSION 0
#define XDG_SHELL_GET_XDG_SURFACE 1
#define XDG_SHELL_GET_XDG_POPUP 2
#define XDG_SHELL_PONG 3

/**
 * @ingroup iface_xdg_shell
 */
#define XDG_SHELL_PING_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_shell
 */
#define XDG_SHELL_USE_UNSTABLE_VERSION_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_shell
 */
#define XDG_SHELL_GET_XDG_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_shell
 */
#define XDG_SHELL_GET_XDG_POPUP_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_shell
 */
#define XDG_SHELL_PONG_SINCE_VERSION 1

/** @ingroup iface_xdg_shell */
static inline void
xdg_shell_set_user_data(struct xdg_shell *xdg_shell, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_shell, user_data);
}

/** @ingroup iface_xdg_shell */
static inline void *
xdg_shell_get_user_data(struct xdg_shell *xdg_shell)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_shell);
}

static inline uint32_t
xdg_shell_get_version(struct xdg_shell *xdg_shell)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_shell);
}

/** @ingroup iface_xdg_shell */
static inline void
xdg_shell_destroy(struct xdg_shell *xdg_shell)
{
	wl_proxy_destroy((struct wl_proxy *) xdg_shell);
}

/**
 * @ingroup iface_xdg_shell
 *
 * Negotiate the unstable version of the interface.  This
 * mechanism is in place to ensure client and server agree on the
 * unstable versions of the protocol that they speak or exit
 * cleanly if they don't agree.  This request will go away once
 * the xdg-shell protocol is stable.
 */
static inline void
xdg_shell_use_unstable_version(struct xdg_shell *xdg_shell, int32_t version)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_shell,
			 XDG_SHELL_USE_UNSTABLE_VERSION, version);
}

/**
 * @ingroup iface_xdg_shell
 *
 * Create a shell surface for an existing surface.
 *
 * Only one shell or popup surface can be associated with a given
 * surface.
 */
static inline struct xdg_surface *
xdg_shell_get_xdg_surface(struct xdg_shell *xdg_shell, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_shell,
			 XDG_SHELL_GET_XDG_SURFACE, &xdg_surface_interface, NULL, surface);

	return (struct xdg_surface *) id;
}

/**
 * @ingroup iface_xdg_shell
 *
 * Create a popup surface for an existing surface.
 *
 * Only one shell or popup surface can be associated with a given
 * surface.
 */
static inline struct xdg_popup *
xdg_shell_get_xdg_popup(struct xdg_shell *xdg_shell, struct wl_surface *surface, struct wl_surface *parent, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y, uint32_t flags)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_shell,
			 XDG_SHELL_GET_XDG_POPUP, &xdg_popup_interface, NULL, surface, parent, seat, serial, x, y, flags);

	return (struct xdg_popup *) id;
}

/**
 * @ingroup iface_xdg_shell
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive.
 */
static inline void
xdg_shell_pong(struct xdg_shell *xdg_shell, uint32_t serial)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_shell,
			 XDG_SHELL_PONG, serial);
}

#ifndef XDG_SURFACE_RESIZE_EDGE_ENUM
#define XDG_SURFACE_RESIZE_EDGE_ENUM
/**
 * @ingroup iface_xdg_surface
 * edge values for resizing
 *
 * These values are used to indicate which edge of a surface
 * is being dragged in a resize operation. The server may
 * use this information to adapt its behavior, e.g. choose
 * an appropriate cursor image.
 */
enum xdg_surface_resize_edge {
	XDG_SURFACE_RESIZE_EDGE_NONE = 0,
	XDG_SURFACE_RESIZE_EDGE_TOP = 1,
	XDG_SURFACE_RESIZE_EDGE_BOTTOM = 2,
	XDG_SURFACE_RESIZE_EDGE_LEFT = 4,
	XDG_SURFACE_RESIZE_EDGE_TOP_LEFT = 5,
	XDG_SURFACE_RESIZE_EDGE_BOTTOM_LEFT = 6,
	XDG_SURFACE_RESIZE_EDGE_RIGHT = 8,
	XDG_SURFACE_RESIZE_EDGE_TOP_RIGHT = 9,
	XDG_SURFACE_RESIZE_EDGE_BOTTOM_RIGHT = 10,
};
#endif /* XDG_SURFACE_RESIZE_EDGE_ENUM */

#ifndef XDG_SURFACE_STATE_ENUM
#define XDG_SURFACE_STATE_ENUM
/**
 * @ingroup iface_xdg_surface
 * types of state on the surface
 *
 * The different state values used on the surface. This is designed for
 * state values like maximized, fullscreen. It is paired with the
 * request_change_state event to ensure that both the client and the
 * compositor setting the state can be synchronized.
 *
 * States set in this way are double-buffered. They will get applied on
 * the next commit.
 *
 * Desktop environments may extend this enum by taking up a range of
 * values and documenting the range they chose in this description.
 * They are not required to document the values for the range that they
 * chose. Ideally, any good extensions from a desktop environment should
 * make its way into standardization into this enum.
 *
 * The current reserved ranges are:
 *
 * 0x0000 - 0x0FFF: xdg-shell core values, documented below.
 * 0x1000 - 0x1FFF: GNOME
 */
enum xdg_surface_state {
	/**
	 * the surface is maximized
	 */
	XDG_SURFACE_STATE_MAXIMIZED = 1,
	/**
	 * the surface is fullscreen
	 */
	XDG_SURFACE_STATE_FULLSCREEN = 2,
};
#endif /* XDG_SURFACE_STATE_ENUM */

/**
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
struct xdg_surface_listener {
	/**
	 * suggest resize
	 *
	 * The configure event asks the client to resize its surface.
	 *
	 * The size is a hint, in the sense that the client is free to
	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
	 * aspect ratio or resize in steps of NxM pixels).
	 *
	 * The client is free to dismiss all but the last configure event
	 * it received.
	 *
	 * The width and height arguments specify the size of the window in
	 * surface local coordinates.
	 */
	void (*configure)(void *data,
			  struct xdg_surface *xdg_surface,
			  int32_t width,
			  int32_t height);
	/**
	 * compositor wants to change a surface's state
	 *
	 * This event tells the client to change a surface's state. The
	 * client should respond with an ack_change_state request to the
	 * compositor to guarantee that the compositor knows that the
	 * client has seen it.
	 * @param state_type the state to set
	 * @param value the value to change the state to
	 * @param serial a serial for the compositor's own tracking
	 */
	void (*change_state)(void *data,
			     struct xdg_surface *xdg_surface,
			     uint32_t state_type,
			     uint32_t value,
			     uint32_t serial);
	/**
	 * surface was activated
	 *
	 * The activated_set event is sent when this surface has been
	 * activated, which means that the surface has user attention.
	 * Window decorations should be updated accordingly. You should not
	 * use this event for anything but the style of decorations you
	 * display, use wl_keyboard.enter and wl_keyboard.leave for
	 * determining keyboard focus.
	 */
	void (*activated)(void *data,
			  struct xdg_surface *xdg_surface);
	/**
	 * surface was deactivated
	 *
	 * The deactivate event is sent when this surface has been
	 * deactivated, which means that the surface lost user attention.
	 * Window decorations should be updated accordingly. You should not
	 * use this event for anything but the style of decorations you
	 * display, use wl_keyboard.enter and wl_keyboard.leave for
	 * determining keyboard focus.
	 */
	void (*deactivated)(void *data,
			    struct xdg_surface *xdg_surface);
	/**
	 * surface wants to be closed
	 *
	 * The close event is sent by the compositor when the user wants
	 * the surface to be closed. This should be equivalent to the user
	 * clicking the close button in client-side decorations, if your
	 * application has any...
	 *
	 * This is only a request that the user intends to close your
	 * window. The client may choose to ignore this request, or show a
	 * dialog to ask the user to save their data...
	 */
	void (*close)(void *data,
		      struct xdg_surface *xdg_surface);
};

/**
 * @ingroup iface_xdg_surface
 */
static inline int
xdg_surface_add_listener(struct xdg_surface *xdg_surface,
			 const struct xdg_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
				     (void (**)(void)) listener, data);
}

#define XDG_SURFACE_DESTROY 0
#define XDG_SURFACE_SET_TRANSIENT_FOR 1
#define XDG_SURFACE_SET_MARGIN 2
#define XDG_SURFACE_SET_TITLE 3
#define XDG_SURFACE_SET_APP_ID 4
#define XDG_SURFACE_MOVE 5
#define XDG_SURFACE_RESIZE 6
#define XDG_SURFACE_SET_OUTPUT 7
#define XDG_SURFACE_REQUEST_CHANGE_STATE 8
#define XDG_SURFACE_ACK_CHANGE_STATE 9
#define XDG_SURFACE_SET_MINIMIZED 10

/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_CHANGE_STATE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_ACTIVATED_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_DEACTIVATED_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_CLOSE_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_TRANSIENT_FOR_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_MARGIN_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_TITLE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_APP_ID_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_MOVE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_RESIZE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_REQUEST_CHANGE_STATE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_ACK_CHANGE_STATE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_SET_MINIMIZED_SINCE_VERSION 1

/** @ingroup iface_xdg_surface */
static inline void
xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
}

/** @ingroup iface_xdg_surface */
static inline void *
xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
}

static inline uint32_t
xdg_surface_get_version(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
}

/**
 * @ingroup iface_xdg_surface
 *
 * The xdg_surface interface is removed from the wl_surface object
 * that was turned into a xdg_surface with
 * xdg_shell.get_xdg_surface request. The xdg_surface properties,
 * like maximized and fullscreen, are lost. The wl_surface loses
 * its role as a xdg_surface. The wl_surface is unmapped.
 */
static inline void
xdg_surface_destroy(struct xdg_surface *xdg_surface)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) xdg_surface);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Setting a surface as transient of another means that it is child
 * of another surface.
 *
 * Child surfaces are stacked above their parents, and will be
 * unmapped if the parent is unmapped too. They should not appear
 * on task bars and alt+tab.
 */
static inline void
xdg_surface_set_transient_for(struct xdg_surface *xdg_surface, struct wl_surface *parent)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_TRANSIENT_FOR, parent);
}

/**
 * @ingroup iface_xdg_surface
 *
 * This tells the compositor what the visible size of the window
 * should be, so it can use it to determine what borders to use for
 * constrainment and alignment.
 *
 * CSD often has invisible areas for decoration purposes, like drop
 * shadows. These "shadow" drawings need to be subtracted out of the
 * normal boundaries of the window when computing where to place
 * windows (e.g. to set this window so it's centered on top of another,
 * or to put it to the left or right of the screen.)
 *
 * This value should change as little as possible at runtime, to
 * prevent flicker.
 *
 * This value is also ignored when the window is maximized or
 * fullscreen, and assumed to be 0.
 *
 * If never called, this value is assumed to be 0.
 */
static inline void
xdg_surface_set_margin(struct xdg_surface *xdg_surface, int32_t left_margin, int32_t right_margin, int32_t top_margin, int32_t bottom_margin)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_MARGIN, left_margin, right_margin, top_margin, bottom_margin);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Set a short title for the surface.
 *
 * This string may be used to identify the surface in a task bar,
 * window list, or other user interface elements provided by the
 * compositor.
 *
 * The string must be encoded in UTF-8.
 */
static inline void
xdg_surface_set_title(struct xdg_surface *xdg_surface, const char *title)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_TITLE, title);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Set an id for the surface.
 *
 * The app id identifies the general class of applications to which
 * the surface belongs.
 *
 * It should be the ID that appears in the new desktop entry
 * specification, the interface name.
 */
static inline void
xdg_surface_set_app_id(struct xdg_surface *xdg_surface, const char *app_id)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_APP_ID, app_id);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Start a pointer-driven move of the surface.
 *
 * This request must be used in response to a button press event.
 * The server may ignore move requests depending on the state of
 * the surface (e.g. fullscreen or maximized).
 */
static inline void
xdg_surface_move(struct xdg_surface *xdg_surface, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_MOVE, seat, serial);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Start a pointer-driven resizing of the surface.
 *
 * This request must be used in response to a button press event.
 * The server may ignore resize requests depending on the state of
 * the surface (e.g. fullscreen or maximized).
 */
static inline void
xdg_surface_resize(struct xdg_surface *xdg_surface, struct wl_seat *seat, uint32_t serial, uint32_t edges)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_RESIZE, seat, serial, edges);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Set the default output used by this surface when it is first mapped.
 *
 * If this value is NULL (default), it's up to the compositor to choose
 * which display will be used to map this surface.
 *
 * When fullscreen or maximized state are set on this surface, and it
 * wasn't mapped yet, the output set with this method will be used.
 * Otherwise, the output where the surface is currently mapped will be
 * used.
 */
static inline void
xdg_surface_set_output(struct xdg_surface *xdg_surface, struct wl_output *output)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_OUTPUT, output);
}

/**
 * @ingroup iface_xdg_surface
 *
 * This asks the compositor to change the state. If the compositor wants
 * to change the state, it will send a change_state event with the same
 * state_type, value, and serial, and the event flow continues as if it
 * it was initiated by the compositor.
 *
 * If the compositor does not want to change the state, it will send a
 * change_state to the client with the old value of the state.
 */
static inline void
xdg_surface_request_change_state(struct xdg_surface *xdg_surface, uint32_t state_type, uint32_t value, uint32_t serial)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_REQUEST_CHANGE_STATE, state_type, value, serial);
}

/**
 * @ingroup iface_xdg_surface
 *
 * When a change_state event is received, a client should then ack it
 * using the ack_change_state request to ensure that the compositor
 * knows the client has seen the event.
 *
 * By this point, the state is confirmed, and the next attach should
 * contain the buffer drawn for the new state value.
 *
 * The values here need to be the same as the values in the cooresponding
 * change_state event.
 */
static inline void
xdg_surface_ack_change_state(struct xdg_surface *xdg_surface, uint32_t state_type, uint32_t value, uint32_t serial)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_ACK_CHANGE_STATE, state_type, value, serial);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Minimize the surface.
 */
static inline void
xdg_surface_set_minimized(struct xdg_surface *xdg_surface)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_SET_MINIMIZED);
}

/**
 * @ingroup iface_xdg_popup
 * @struct xdg_popup_listener
 */
struct xdg_popup_listener {
	/**
	 * popup interaction is done
	 *
	 * The popup_done event is sent out when a popup grab is broken,
	 * that is, when the users clicks a surface that doesn't belong to
	 * the client owning the popup surface.
	 * @param serial serial of the implicit grab on the pointer
	 */
	void (*popup_done)(void *data,
			   struct xdg_popup *xdg_popup,
			   uint32_t serial);
};

/**
 * @ingroup iface_xdg_popup
 */
static inline int
xdg_popup_add_listener(struct xdg_popup *xdg_popup,
		       const struct xdg_popup_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
				     (void (**)(void)) listener, data);
}

#define XDG_POPUP_DESTROY 0

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_DESTROY_SINCE_VERSION 1

/** @ingroup iface_xdg_popup */
static inline void
xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
}

/** @ingroup iface_xdg_popup */
static inline void *
xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
}

static inline uint32_t
xdg_popup_get_version(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
}

/**
 * @ingroup iface_xdg_popup
 *
 * The xdg_surface interface is removed from the wl_surface object
 * that was turned into a xdg_surface with
 * xdg_shell.get_xdg_surface request. The xdg_surface properties,
 * like maximized and fullscreen, are lost. The wl_surface loses
 * its role as a xdg_surface. The wl_surface is unmapped.
 */
static inline void
xdg_popup_destroy(struct xdg_popup *xdg_popup)
{
	wl_proxy_marshal((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) xdg_popup);
}

#ifdef  __cplusplus
}
#endif

#endif
